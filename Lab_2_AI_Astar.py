import csv
import heapq

def read_graph_from_csv(csv_file):
    graph = []
    cities = {}  # Словарь для соответствия имен городов и их индексов в матрице смежности
    with open(csv_file, 'r', newline='') as file:
        reader = csv.reader(file)
        cities_list = next(reader)  # Получаем список имен городов из первой строки
        for index, city in enumerate(cities_list):
            cities[city] = index
        for row in reader:
            graph.append([int(cell) for cell in row])
    return graph, cities

def a_star(graph, start, goal):
    # Определяем функцию для оценки расстояния от текущей вершины до цели
    def heuristic(n):
        return graph[n][goal]
    
    # Очередь с приоритетами для хранения узлов для обработки
    open_list = [(0, start)]
    # Словарь для хранения путей от стартовой вершины до каждой другой вершины
    came_from = {}
    # Словарь для хранения стоимости пути от стартовой вершины до каждой другой вершины
    g_score = {city: float('inf') for city in range(len(graph))}
    g_score[start] = 0
    
    while open_list:
        # Извлекаем вершину с наименьшей стоимостью из очереди
        current_cost, current_node = heapq.heappop(open_list)
        
        # Если текущая вершина - целевая, возвращаем путь
        if current_node == goal:
            path = []
            while current_node in came_from:
                path.insert(0, current_node)
                current_node = came_from[current_node]
            path.insert(0, start)
            return path
        
        # Обходим соседей текущей вершины
        for neighbor, distance in enumerate(graph[current_node]):
            if distance > 0:  # Проверяем, есть ли дорога к соседу
                tentative_g_score = g_score[current_node] + distance
                if tentative_g_score < g_score[neighbor]:
                    # Обновляем стоимость пути до соседа
                    g_score[neighbor] = tentative_g_score
                    # Вычисляем оценку стоимости пути через соседа до цели
                    f_score = tentative_g_score + heuristic(neighbor)
                    # Добавляем соседа в очередь с приоритетами
                    heapq.heappush(open_list, (f_score, neighbor))
                    # Запоминаем предыдущую вершину для соседа
                    came_from[neighbor] = current_node
    
    # Если не удалось найти путь
    return None

# Функция для выбора города
def choose_city(cities):
    print("Доступные города:")
    for city in cities:
        print(city)
    start = input("Введите начальный город: ")
    goal = input("Введите конечный город: ")
    return cities[start], cities[goal]

if __name__ == "__main__":
    csv_file = "D:\Present\AI\Lab_2\map.csv"
    graph, cities = read_graph_from_csv(csv_file)
    
    start, goal = choose_city(cities)
    
    path = a_star(graph, start, goal)
    if path:
        print("Путь из", start, "в", goal, ":", path)
    else:
        print("Путь не найден.")

"""
Особенности алгоритма A* (A-star):
- Комбинация алгоритмов поиска в ширину (BFS) и алгоритма Дейкстры, что позволяет объединить эффективность поиска в ширину и точность алгоритма Дейкстры.
- Использует эвристическую функцию (heuristic), которая оценивает стоимость пути от текущей вершины до цели. Это позволяет алгоритму принимать более информированные решения о выборе следующей вершины для исследования.
- При выборе вершин для исследования учитывается как стоимость пути от начальной вершины до текущей (через предыдущие вершины), так и эвристическая оценка стоимости пути от текущей вершины до цели. Таким образом, алгоритм стремится исследовать более перспективные направления.
- Позволяет находить кратчайший путь от начальной вершины к цели, учитывая стоимости ребер между вершинами и эвристическую оценку стоимости оставшегося пути.
- Эффективен в поиске кратчайших путей в графах с большим количеством вершин и ребер.
"""

"""
Начать с исходного узла и целевого узла.
Инициализировать два списка: открытый список и закрытый список. Открытый список содержит узлы, которые еще не были исследованы, а закрытый список содержит узлы, которые уже были исследованы.
Поместить начальный узел в открытый список.
Повторять следующие шаги, пока открытый список не станет пустым или не будет найден целевой узел:
а. Выбрать узел из открытого списка с наименьшей оценкой f(x), где f(x) = g(x) + h(x), а g(x) - стоимость пути от начального узла до узла x, а h(x) - эвристическая оценка стоимости пути от узла x до целевого узла.
б. Переместить выбранный узел из открытого списка в закрытый список.
с. Для каждого соседнего узла текущего узла:
i. Если соседний узел не проходим (например, стена) или уже находится в закрытом списке, проигнорировать его.
ii. Если соседний узел еще не находится в открытом списке, добавить его туда и вычислить значения g(x), h(x) и f(x).
iii. Если соседний узел уже находится в открытом списке, проверить, является ли новый путь до него лучше (имеет более низкую стоимость). Если так, обновить значения g(x), h(x) и f(x) для этого узла, а также обновить его родителя.
Когда целевой узел найден, восстановить путь, следуя обратно по родителям от целевого узла к начальному.
"""